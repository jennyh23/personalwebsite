<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jenny's World — Interactive Resume</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='22' fill='%2395D5B2'/%3E%3Ctext x='50' y='68' font-size='56' text-anchor='middle' fill='%235D4E37' font-family='monospace'%3EJH%3C/text%3E%3C/svg%3E" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #1a2a1a; font-family: 'Press Start 2P', cursive; }
    canvas { display: block; image-rendering: pixelated; }

    #splash {
      position: fixed; inset: 0; z-index: 200;
      background: #1a2a1a;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      transition: opacity 1s ease;
    }
    #splash.fade { opacity: 0; pointer-events: none; }
    #splash h1 {
      font-size: clamp(18px, 4vw, 36px); color: #FAF3E0;
      margin-bottom: 6px; text-shadow: 3px 3px 0 #52A375;
    }
    #splash h2 {
      font-size: clamp(8px, 1.8vw, 14px); color: #7BC9A0;
      margin-bottom: 50px; font-weight: normal;
    }
    #splash .start {
      font-size: clamp(8px, 1.5vw, 11px); color: #9B8B7A;
      animation: blink 1.2s steps(2) infinite;
    }
    #splash .controls {
      margin-top: 40px; font-size: clamp(7px, 1.2vw, 9px);
      color: #5D4E37; line-height: 2.5; text-align: center;
    }
    @keyframes blink { 50% { opacity: 0; } }

    #dialogue {
      display: none; position: fixed;
      bottom: 30px; left: 50%; transform: translateX(-50%);
      width: min(640px, 92vw); z-index: 100;
      background: #52A375;
      clip-path: polygon(
        0px 8px, 4px 8px, 4px 4px, 8px 4px, 8px 0px,
        calc(100% - 8px) 0px, calc(100% - 8px) 4px, calc(100% - 4px) 4px, calc(100% - 4px) 8px, 100% 8px,
        100% calc(100% - 8px), calc(100% - 4px) calc(100% - 8px), calc(100% - 4px) calc(100% - 4px), calc(100% - 8px) calc(100% - 4px), calc(100% - 8px) 100%,
        8px 100%, 8px calc(100% - 4px), 4px calc(100% - 4px), 4px calc(100% - 8px), 0px calc(100% - 8px)
      );
    }
    #dialogue .inner {
      margin: 4px; padding: 20px 24px;
      background: #FAF3E0;
      clip-path: polygon(
        0px 6px, 3px 6px, 3px 3px, 6px 3px, 6px 0px,
        calc(100% - 6px) 0px, calc(100% - 6px) 3px, calc(100% - 3px) 3px, calc(100% - 3px) 6px, 100% 6px,
        100% calc(100% - 6px), calc(100% - 3px) calc(100% - 6px), calc(100% - 3px) calc(100% - 3px), calc(100% - 6px) calc(100% - 3px), calc(100% - 6px) 100%,
        6px 100%, 6px calc(100% - 3px), 3px calc(100% - 3px), 3px calc(100% - 6px), 0px calc(100% - 6px)
      );
    }
    #dlg-title {
      font-size: clamp(9px, 1.5vw, 12px); color: #52A375;
      margin-bottom: 12px;
    }
    #dlg-content {
      font-size: clamp(8px, 1.3vw, 11px); color: #5D4E37;
      line-height: 2.2; min-height: 60px; white-space: pre-wrap;
    }
    #dlg-footer {
      display: flex; justify-content: space-between;
      align-items: center; margin-top: 14px;
    }
    #dlg-page {
      font-size: 8px; color: #9B8B7A;
    }
    #dlg-prompt {
      font-size: 9px; color: #9B8B7A;
      animation: blink 1s steps(2) infinite;
    }

    #back-link {
      position: fixed; top: 14px; left: 14px; z-index: 150;
      font-size: 9px; color: #FAF3E0;
      background: rgba(42, 63, 42, 0.8); padding: 8px 14px;
      text-decoration: none; border: 2px solid #52A375;
      transition: background 0.2s;
    }
    #back-link:hover { background: rgba(42, 63, 42, 1); }

    /* Hide back-link and hint when embedded in iframe */
    .in-iframe #back-link,
    .in-iframe #hint { display: none; }

    #hint {
      position: fixed; bottom: 14px; left: 14px; z-index: 90;
      font-size: 8px; color: rgba(250,243,224,0.5);
      line-height: 2;
    }

    #touch-controls {
      display: none; position: fixed; z-index: 150;
    }
    @media (pointer: coarse) {
      #touch-controls { display: block; }
      #hint { display: none; }
    }
    .dpad {
      position: fixed; bottom: 20px; left: 20px;
      width: 120px; height: 120px;
    }
    .dpad button {
      position: absolute; width: 40px; height: 40px;
      background: rgba(42,63,42,0.6); border: 2px solid #52A375;
      color: #FAF3E0; font-size: 16px; font-family: inherit;
      display: flex; align-items: center; justify-content: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }
    .dpad .up { top: 0; left: 40px; }
    .dpad .down { bottom: 0; left: 40px; }
    .dpad .left { top: 40px; left: 0; }
    .dpad .right { top: 40px; right: 0; }
    .action-btn {
      position: fixed; bottom: 30px; right: 30px;
      width: 56px; height: 56px; border-radius: 50%;
      background: rgba(82,163,117,0.7); border: 3px solid #FAF3E0;
      color: #FAF3E0; font-size: 18px; font-family: inherit;
      display: flex; align-items: center; justify-content: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="world"></canvas>

  <div id="splash" tabindex="0">
    <h1>Jenny's World</h1>
    <h2>Interactive Resume</h2>
    <div class="start">Click or press SPACE to start</div>
    <div class="controls">
      Arrow keys to move<br>
      SPACE to interact
    </div>
  </div>

  <div id="dialogue">
    <div class="inner">
      <div id="dlg-title"></div>
      <div id="dlg-content"></div>
      <div id="dlg-footer">
        <span id="dlg-page"></span>
        <span id="dlg-prompt">SPACE ▼</span>
      </div>
    </div>
  </div>

  <a id="back-link" href="index.html">&#x2190; Portfolio</a>

  <div id="hint">
    Arrow keys: move<br>
    Space: interact
  </div>

  <div id="touch-controls">
    <div class="dpad">
      <button class="up" data-dir="up">&#x25B2;</button>
      <button class="down" data-dir="down">&#x25BC;</button>
      <button class="left" data-dir="left">&#x25C0;</button>
      <button class="right" data-dir="right">&#x25B6;</button>
    </div>
    <button class="action-btn" id="touch-action">A</button>
  </div>

<script>
// Hide UI chrome when embedded in iframe
if (window.self !== window.top) {
  document.body.classList.add('in-iframe');
}

// ═══════════════════════════════════════
// SETUP
// ═══════════════════════════════════════
const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
const S = 3;
const TILE = 16;
const MW = 28, MH = 20;

let groundCache = null;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  if (groundCache) renderGroundCache();
}
window.addEventListener('resize', resize);
resize();

// ═══════════════════════════════════════
// COLORS
// ═══════════════════════════════════════
const COL = {
  grass1: '#7BC9A0',
  grass2: '#6EC08F',
  grassDark: '#5DAF7E',
  path: '#F0DCA0',
  pathEdge: '#D8C898',
  pathDark: '#C8B878',
  water: '#82C8EE',
  waterLight: '#A2D8FF',
  waterDark: '#5EAAD0',
  waterEdge: '#B8E0D2',
  sand: '#F0DCA0',
  treeTrunk: '#8B6B4A',
  treeTrunkDark: '#705838',
  canopy: '#52A375',
  canopyLight: '#6BBE8E',
  canopyDark: '#3D8A5E',
  hair: '#2D1B0E',
  skin: '#FFDAB9',
  skinShadow: '#F0C098',
  eyes: '#2D1B0E',
  eyeWhite: '#FFFFFF',
  blush: '#FFB4A2',
  shirt: '#F2A0B8',
  shirtDark: '#D88AA0',
  skirt: '#E8D5B0',
  shoes: '#8B6B4A',
  wallCream: '#FAF3E0',
  wallShadow: '#E8DCC8',
  wallWhite: '#FFF8F0',
  sandstone: '#E8D5B0',
  sandstoneDark: '#D4C09A',
  sandstoneLt: '#F0E0C4',
  towerBeige: '#E0CCA0',
  towerBeigeDk: '#C8B488',
  towerCap: '#D4B86A',
  archBrown: '#8B7355',
  fountainStone: '#D8D0C0',
  fountainStoneDk: '#C0B8A8',
  palmTrunk: '#9B7B55',
  palmTrunkDk: '#806540',
  palmFrond: '#5DAF7E',
  palmFrondDk: '#4A9A68',
  palmFrondLt: '#78C89A',
  doorBrown: '#8B6B4A',
  doorDark: '#705838',
  windowBlue: '#A2D2FF',
  windowFrame: '#E8DCC8',
  roofRed: '#C97B63',
  roofRedDark: '#A86850',
  roofBlue: '#7B9EC9',
  roofBlueDark: '#5E80A8',
  roofPink: '#E5A0B8',
  roofPinkDark: '#CC8AA0',
  roofGold: '#D4B86A',
  roofGoldDark: '#B89E55',
  roofLavender: '#B899CC',
  roofLavDark: '#9A80B0',
  roofMint: '#6BBE8E',
  roofMintDark: '#52A375',
  shadow: 'rgba(0,0,0,0.08)',
  textDark: '#5D4E37',
  fenceBrown: '#A08060',
  flowerPink: '#FFB4A2',
  flowerYellow: '#FFF3B0',
  flowerPurple: '#E5C1CD',
  flowerWhite: '#FFF8F0',
  flowerCenter: '#FFE082',
};

// ═══════════════════════════════════════
// STATE
// ═══════════════════════════════════════
const keys = {};
let started = false;
let time = 0;
let dlgActive = false;
let dlgBuilding = null;
let dlgPage = 0;
let dlgCharIdx = 0;
let nearBuilding = null;

const player = {
  x: 14 * TILE + 8,
  y: 15 * TILE + 8,
  w: 10, h: 14,
  dir: 'down',
  frame: 0,
  frameTimer: 0,
  speed: 1.6,
  moving: false,
};

const cam = { x: 0, y: 0 };

// ═══════════════════════════════════════
// BUILDINGS
// ═══════════════════════════════════════
const buildings = [
  {
    id: 'education', name: 'University',
    x: 2, y: 3, w: 4, h: 2,
    roof: COL.roofRed, roofDk: COL.roofRedDark,
    wall: COL.sandstone, wallDk: COL.sandstoneDark,
    sign: 'STANFORD', signColor: COL.roofRed,
    pages: [
      { title: '\u{1F393} Stanford University', text: 'BS Symbolic Systems\nHCI Concentration' },
      { title: '\u{1F393} Affiliations', text: 'Forbes Under 30\nStanford ASES\nWiCS\nNEXT Creator Collective\nBOSP: Peking University' },
    ],
  },
  {
    id: 'creator', name: 'Studio',
    x: 22, y: 2, w: 4, h: 2,
    roof: COL.roofLavender, roofDk: COL.roofLavDark,
    wall: COL.sandstone, wallDk: COL.sandstoneDark,
    sign: 'STUDIO', signColor: COL.roofLavender,
    pages: [
      { title: '\u{1F3A5} Jenny Huynh \u2014 Creator', text: 'Built a large cross-platform\naudience across social media.\n\nDeveloped brand strategy with\ninternational companies.\n\nProduced lifestyle and media\ncontent at scale.' },
    ],
  },
  {
    id: 'entrepreneur', name: 'Boutique',
    x: 4, y: 8, w: 4, h: 2,
    roof: COL.roofPink, roofDk: COL.roofPinkDark,
    wall: '#FFF0F0', wallDk: '#F0D8D8',
    sign: 'BOUTIQUE', signColor: COL.roofPink,
    pages: [
      { title: '\u{1F3EA} Whoop \u2014 Founder', text: 'Anaheim, CA\n\nDesigned and launched\nsustainable fashion products.\n\nLed brand strategy and\nmulti-platform marketing.' },
      { title: '\u{1F3EA} Jenny Slime \u2014 CEO', text: 'Vietnam\n\nBuilt a consumer brand\nand social presence.\n\nManaged product production\nand growth strategy.' },
    ],
  },
  {
    id: 'experience', name: 'Offices',
    x: 20, y: 9, w: 4, h: 2,
    roof: COL.roofBlue, roofDk: COL.roofBlueDark,
    wall: COL.sandstone, wallDk: COL.sandstoneDark,
    sign: 'EXPERIENCE', signColor: COL.roofBlue,
    pages: [
      { title: '\u{1F3E2} Pika \u2014 PM Intern', text: 'Palo Alto, CA\n\nLed cross-functional product\ndesign and go-to-market for\nan AI video platform.\n\nImproved publishing workflow\nand user satisfaction.\n\nBuilt and scaled a creator\nonboarding program.' },
      { title: '\u{1F3E2} TikTok \u2014 Product Ops', text: 'San Jose, CA\n\nImproved creator vetting systems.\n\nPartnered with engineers to\nenhance dashboard UX.\n\nOptimized international creator\ngrowth strategies.\n\nBuilt structured performance\nanalysis frameworks.' },
      { title: '\u{1F3E2} Valuenex \u2014 Data Analyst', text: 'Palo Alto, CA\n\nLed engagement campaigns\nusing trend analysis.\n\nAdvised executives on product\nstrategy using analytics.' },
    ],
  },
  {
    id: 'awards', name: 'Town Hall',
    x: 3, y: 14, w: 4, h: 2,
    roof: COL.roofGold, roofDk: COL.roofGoldDark,
    wall: COL.sandstone, wallDk: COL.sandstoneDark,
    sign: 'TOWN HALL', signColor: COL.roofGold,
    pages: [
      { title: '\u{1F3C6} Awards', text: 'Forbes Under 30 Asia\n  Media, Marketing &\n  Advertising\n\nTreeHacks\n  Best Hack Connecting\n  with Others\n\nJane Street Estimation\n  First Place' },
    ],
  },
  {
    id: 'skills', name: 'Tech Lab',
    x: 21, y: 13, w: 4, h: 2,
    roof: COL.roofMint, roofDk: COL.roofMintDark,
    wall: COL.sandstone, wallDk: COL.sandstoneDark,
    sign: 'TECH LAB', signColor: COL.roofMint,
    pages: [
      { title: '\u{1F9E0} Technical Skills', text: 'Python \u00B7 C++ \u00B7 JavaScript\nReact Native\n\nLanguages:\n  English (native)\n  Vietnamese (fluent)\n  Chinese (conversational)' },
    ],
  },
];

// Hoover Tower - special centerpiece building
const hooverTower = {
  x: 12, y: 4, w: 2, h: 5,
  sign: 'HOOVER TOWER',
  pages: [
    { title: '\u{1F3DB} Hoover Tower', text: 'Stanford\'s iconic 285-foot\ntower and landmark.\n\nWelcome to Jenny\'s\nStanford Campus!' },
  ],
};

// Palm trees along Palm Drive
const palmTrees = [];
for (let ty = 12; ty <= 18; ty += 3) {
  palmTrees.push({ x: 12 * TILE, y: ty * TILE });
  palmTrees.push({ x: 15 * TILE, y: ty * TILE });
}
palmTrees.push({ x: 2 * TILE, y: 2 * TILE });
palmTrees.push({ x: 25 * TILE, y: 2 * TILE });
palmTrees.push({ x: 9 * TILE, y: 10 * TILE });
palmTrees.push({ x: 18 * TILE, y: 10 * TILE });

// ═══════════════════════════════════════
// PATHS (in tile coords)
// ═══════════════════════════════════════
const paths = [
  // Palm Drive — winding N-S with offsets
  { x: 13, y: 2, w: 2, h: 4 },
  { x: 12, y: 6, w: 2, h: 3 },
  { x: 13, y: 9, w: 2, h: 2 },
  { x: 13, y: 13, w: 2, h: 5 },
  // Upper path — curves toward buildings
  { x: 4, y: 5, w: 4, h: 1 },
  { x: 8, y: 5, w: 2, h: 1 },
  { x: 10, y: 6, w: 3, h: 1 },
  { x: 15, y: 5, w: 3, h: 1 },
  { x: 18, y: 4, w: 4, h: 1 },
  // Middle path — meanders to fountain area
  { x: 5, y: 10, w: 3, h: 1 },
  { x: 8, y: 10, w: 2, h: 1 },
  { x: 17, y: 10, w: 2, h: 1 },
  { x: 19, y: 11, w: 2, h: 1 },
  // Lower path — connects bottom buildings
  { x: 4, y: 16, w: 3, h: 1 },
  { x: 7, y: 15, w: 3, h: 1 },
  { x: 10, y: 15, w: 3, h: 1 },
  { x: 15, y: 15, w: 3, h: 1 },
  { x: 18, y: 15, w: 4, h: 1 },
  // Left branch — wiggly N-S
  { x: 5, y: 5, w: 1, h: 3 },
  { x: 6, y: 8, w: 1, h: 2 },
  { x: 5, y: 10, w: 1, h: 3 },
  { x: 5, y: 13, w: 1, h: 3 },
  // Right branch — wiggly N-S
  { x: 22, y: 4, w: 1, h: 3 },
  { x: 21, y: 7, w: 1, h: 3 },
  { x: 22, y: 11, w: 1, h: 2 },
  { x: 22, y: 13, w: 1, h: 3 },
  // Central plaza — irregular shape around fountain
  { x: 10, y: 10, w: 8, h: 3 },
  { x: 11, y: 9, w: 6, h: 1 },
  { x: 11, y: 13, w: 6, h: 1 },
];

// ═══════════════════════════════════════
// TREES
// ═══════════════════════════════════════
const trees = [];

function placeTrees() {
  const occupied = new Set();

  // Mark building areas and paths as occupied
  buildings.forEach(b => {
    for (let ty = b.y - 2; ty < b.y + b.h + 3; ty++)
      for (let tx = b.x - 2; tx < b.x + b.w + 2; tx++)
        occupied.add(`${tx},${ty}`);
  });
  // Hoover Tower
  for (let ty = hooverTower.y - 2; ty < hooverTower.y + hooverTower.h + 3; ty++)
    for (let tx = hooverTower.x - 2; tx < hooverTower.x + hooverTower.w + 2; tx++)
      occupied.add(`${tx},${ty}`);
  paths.forEach(p => {
    for (let ty = p.y - 1; ty < p.y + p.h + 1; ty++)
      for (let tx = p.x - 1; tx < p.x + p.w + 1; tx++)
        occupied.add(`${tx},${ty}`);
  });
  // Fountain area
  for (let ty = fountain.y - 2; ty < fountain.y + fountain.h + 2; ty++)
    for (let tx = fountain.x - 2; tx < fountain.x + fountain.w + 2; tx++)
      occupied.add(`${tx},${ty}`);
  // Palm tree positions
  palmTrees.forEach(pt => {
    const tx = Math.floor(pt.x / TILE);
    const ty = Math.floor(pt.y / TILE);
    occupied.add(`${tx},${ty}`);
    occupied.add(`${tx + 1},${ty}`);
  });
  // Player spawn area
  for (let ty = 13; ty < 17; ty++)
    for (let tx = 12; tx < 16; tx++)
      occupied.add(`${tx},${ty}`);

  // Border trees
  for (let tx = 0; tx < MW; tx += 2) {
    if (!occupied.has(`${tx},0`)) trees.push({ x: tx * TILE, y: 0 * TILE, size: 1 });
    if (!occupied.has(`${tx},1`)) trees.push({ x: tx * TILE, y: 1 * TILE, size: 1 });
    if (!occupied.has(`${tx},${MH - 2}`)) trees.push({ x: tx * TILE, y: (MH - 2) * TILE, size: 1 });
    if (!occupied.has(`${tx},${MH - 1}`)) trees.push({ x: tx * TILE, y: (MH - 1) * TILE, size: 1 });
  }
  for (let ty = 0; ty < MH; ty += 2) {
    if (!occupied.has(`0,${ty}`)) trees.push({ x: 0, y: ty * TILE, size: 1 });
    if (!occupied.has(`1,${ty}`)) trees.push({ x: 1 * TILE, y: ty * TILE, size: 1 });
    if (!occupied.has(`${MW - 2},${ty}`)) trees.push({ x: (MW - 2) * TILE, y: ty * TILE, size: 1 });
    if (!occupied.has(`${MW - 1},${ty}`)) trees.push({ x: (MW - 1) * TILE, y: ty * TILE, size: 1 });
  }

  // Scatter interior trees
  const rng = mulberry32(42);
  for (let i = 0; i < 40; i++) {
    const tx = Math.floor(rng() * MW);
    const ty = Math.floor(rng() * MH);
    if (!occupied.has(`${tx},${ty}`) && !occupied.has(`${tx + 1},${ty}`) &&
        !occupied.has(`${tx},${ty + 1}`) && !occupied.has(`${tx + 1},${ty + 1}`)) {
      trees.push({ x: tx * TILE, y: ty * TILE, size: rng() > 0.5 ? 1 : 0.8 });
      occupied.add(`${tx},${ty}`);
      occupied.add(`${tx + 1},${ty}`);
    }
  }
}

function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// ═══════════════════════════════════════
// FLOWERS
// ═══════════════════════════════════════
const flowers = [];
function placeFlowers() {
  const rng = mulberry32(99);
  const occupied = new Set();
  buildings.forEach(b => {
    for (let ty = b.y - 1; ty < b.y + b.h + 2; ty++)
      for (let tx = b.x - 1; tx < b.x + b.w + 1; tx++)
        occupied.add(`${tx},${ty}`);
  });
  // Hoover Tower
  for (let ty = hooverTower.y - 1; ty < hooverTower.y + hooverTower.h + 2; ty++)
    for (let tx = hooverTower.x - 1; tx < hooverTower.x + hooverTower.w + 1; tx++)
      occupied.add(`${tx},${ty}`);
  paths.forEach(p => {
    for (let ty = p.y; ty < p.y + p.h; ty++)
      for (let tx = p.x; tx < p.x + p.w; tx++)
        occupied.add(`${tx},${ty}`);
  });
  // Fountain
  for (let ty = fountain.y - 1; ty < fountain.y + fountain.h + 1; ty++)
    for (let tx = fountain.x - 1; tx < fountain.x + fountain.w + 1; tx++)
      occupied.add(`${tx},${ty}`);

  for (let i = 0; i < 25; i++) {
    const tx = Math.floor(rng() * MW);
    const ty = Math.floor(rng() * MH);
    if (!occupied.has(`${tx},${ty}`)) {
      flowers.push({
        x: tx * TILE + Math.floor(rng() * 10),
        y: ty * TILE + Math.floor(rng() * 10),
        type: Math.floor(rng() * 4),
        phase: rng() * Math.PI * 2,
      });
    }
  }
}

// ═══════════════════════════════════════
// FOUNTAIN (replaces pond)
// ═══════════════════════════════════════
const fountain = { x: 11, y: 10, w: 6, h: 3 };

// ═══════════════════════════════════════
// COLLISION
// ═══════════════════════════════════════
let collisionBoxes = [];

function buildCollisions() {
  collisionBoxes = [];

  // Map borders
  collisionBoxes.push({ x: -TILE, y: -TILE, w: (MW + 2) * TILE, h: TILE * 2 });
  collisionBoxes.push({ x: -TILE, y: (MH - 1) * TILE, w: (MW + 2) * TILE, h: TILE * 2 });
  collisionBoxes.push({ x: -TILE, y: -TILE, w: TILE * 2, h: (MH + 2) * TILE });
  collisionBoxes.push({ x: (MW - 1) * TILE, y: -TILE, w: TILE * 2, h: (MH + 2) * TILE });

  // Buildings
  buildings.forEach(b => {
    collisionBoxes.push({
      x: b.x * TILE, y: b.y * TILE,
      w: b.w * TILE, h: b.h * TILE,
    });
  });

  // Hoover Tower
  collisionBoxes.push({
    x: hooverTower.x * TILE, y: hooverTower.y * TILE,
    w: hooverTower.w * TILE, h: hooverTower.h * TILE,
  });

  // Trees
  trees.forEach(t => {
    collisionBoxes.push({ x: t.x + 5, y: t.y + 12, w: 6, h: 6 });
  });

  // Palm trees
  palmTrees.forEach(t => {
    collisionBoxes.push({ x: t.x + 4, y: t.y + 14, w: 5, h: 5 });
  });

  // Fountain
  collisionBoxes.push({
    x: fountain.x * TILE, y: fountain.y * TILE,
    w: fountain.w * TILE, h: fountain.h * TILE,
  });
}

function canMove(nx, ny) {
  const pw = 6, ph = 4;
  const px = nx - pw / 2;
  const py = ny + 4;

  for (const box of collisionBoxes) {
    if (px < box.x + box.w && px + pw > box.x &&
        py < box.y + box.h && py + ph > box.y) {
      return false;
    }
  }
  return true;
}

// ═══════════════════════════════════════
// DRAWING HELPERS
// ═══════════════════════════════════════
function px(gx, gy, gw, gh, color) {
  ctx.fillStyle = color;
  ctx.fillRect(
    Math.round(gx * S - cam.x),
    Math.round(gy * S - cam.y),
    Math.ceil(gw * S),
    Math.ceil(gh * S)
  );
}

function pxText(text, gx, gy, size, color) {
  ctx.font = `${size}px "Press Start 2P"`;
  ctx.fillStyle = color;
  ctx.textAlign = 'center';
  ctx.fillText(text, Math.round(gx * S - cam.x), Math.round(gy * S - cam.y));
}

// ═══════════════════════════════════════
// GROUND (cached)
// ═══════════════════════════════════════
function renderGroundCache() {
  const gc = document.createElement('canvas');
  gc.width = MW * TILE * S;
  gc.height = MH * TILE * S;
  const g = gc.getContext('2d');

  // Base grass with checkerboard pattern
  for (let ty = 0; ty < MH; ty++) {
    for (let tx = 0; tx < MW; tx++) {
      const shade = ((Math.floor(tx / 2) + Math.floor(ty / 2)) % 2 === 0) ? COL.grass1 : COL.grass2;
      g.fillStyle = shade;
      g.fillRect(tx * TILE * S, ty * TILE * S, TILE * S, TILE * S);
    }
  }

  // Grass detail marks
  const rng = mulberry32(7);
  g.fillStyle = COL.grassDark;
  for (let i = 0; i < 400; i++) {
    const gx = Math.floor(rng() * MW * TILE);
    const gy = Math.floor(rng() * MH * TILE);
    const t = Math.floor(rng() * 3);
    if (t === 0) {
      g.fillRect(gx * S, gy * S, S, S * 2);
    } else if (t === 1) {
      g.fillRect(gx * S, gy * S, S, S);
      g.fillRect((gx + 1) * S, (gy + 1) * S, S, S);
    } else {
      g.fillRect(gx * S, gy * S, S * 2, S);
    }
  }

  // Paths
  paths.forEach(p => {
    // Path edge (darker)
    g.fillStyle = COL.pathEdge;
    g.fillRect(
      (p.x * TILE - 1) * S, (p.y * TILE - 1) * S,
      (p.w * TILE + 2) * S, (p.h * TILE + 2) * S
    );
    // Path fill
    g.fillStyle = COL.path;
    g.fillRect(
      p.x * TILE * S, p.y * TILE * S,
      p.w * TILE * S, p.h * TILE * S
    );
    // Path texture
    g.fillStyle = COL.pathDark;
    for (let py = p.y * TILE; py < (p.y + p.h) * TILE; py += 8) {
      for (let px = p.x * TILE; px < (p.x + p.w) * TILE; px += 8) {
        if ((Math.floor(px / 8) + Math.floor(py / 8)) % 3 === 0) {
          g.fillRect(px * S + S, py * S + S, S, S);
        }
      }
    }
  });

  // Fountain courtyard
  g.fillStyle = COL.pathDark;
  g.fillRect(
    (fountain.x - 1) * TILE * S, (fountain.y - 1) * TILE * S,
    (fountain.w + 2) * TILE * S, (fountain.h + 2) * TILE * S
  );
  g.fillStyle = COL.path;
  g.fillRect(
    fountain.x * TILE * S, fountain.y * TILE * S,
    fountain.w * TILE * S, fountain.h * TILE * S
  );
  // Fountain basin (stone ring)
  const fi = 3;
  g.fillStyle = COL.fountainStone;
  g.fillRect(
    (fountain.x * TILE + fi) * S, (fountain.y * TILE + fi) * S,
    (fountain.w * TILE - fi * 2) * S, (fountain.h * TILE - fi * 2) * S
  );
  g.fillStyle = COL.fountainStoneDk;
  g.fillRect(
    (fountain.x * TILE + fi) * S, (fountain.y * TILE + fountain.h * TILE - fi - 2) * S,
    (fountain.w * TILE - fi * 2) * S, 2 * S
  );
  // Fountain water
  const wi = 6;
  g.fillStyle = COL.water;
  g.fillRect(
    (fountain.x * TILE + wi) * S, (fountain.y * TILE + wi) * S,
    (fountain.w * TILE - wi * 2) * S, (fountain.h * TILE - wi * 2) * S
  );
  g.fillStyle = COL.waterDark;
  g.fillRect(
    (fountain.x * TILE + wi + 4) * S, (fountain.y * TILE + wi + 3) * S,
    (fountain.w * TILE - wi * 2 - 8) * S, (fountain.h * TILE - wi * 2 - 6) * S
  );

  groundCache = gc;
}

function drawGround() {
  if (!groundCache) renderGroundCache();
  ctx.drawImage(groundCache, -cam.x, -cam.y);
}

// ═══════════════════════════════════════
// FOUNTAIN ANIMATION
// ═══════════════════════════════════════
function drawFountainAnim() {
  const cx = (fountain.x + fountain.w / 2) * TILE;
  const cy = (fountain.y + fountain.h / 2) * TILE;

  // Water spray particles
  for (let i = 0; i < 5; i++) {
    const phase = time * 0.05 + i * 1.2;
    const t = (Math.sin(phase) * 0.5 + 0.5);
    const dropY = cy - t * 8;
    const dropX = cx + Math.sin(phase * 2.3 + i) * (2 + t * 3);
    if (t > 0.1) {
      px(dropX, dropY, 1, 1, COL.waterLight);
    }
  }

  // Surface shimmer
  for (let i = 0; i < 3; i++) {
    const phase = time * 0.03 + i * 2.0;
    const wx = fountain.x * TILE + 7 + ((Math.sin(phase) * 0.5 + 0.5) * (fountain.w * TILE - 14));
    const wy = fountain.y * TILE + 7 + ((Math.cos(phase * 0.7) * 0.5 + 0.5) * (fountain.h * TILE - 14));
    px(wx, wy, 2, 1, COL.waterLight);
  }
}

// ═══════════════════════════════════════
// BUILDINGS DRAWING (cute Stanford style)
// ═══════════════════════════════════════
function drawBuilding(b) {
  const bx = b.x * TILE;
  const by = b.y * TILE;
  const bw = b.w * TILE;  // 64
  const bh = b.h * TILE;  // 32

  const roofH = 10;
  const wallY = by + roofH;
  const wallH = bh - roofH;

  // Shadow
  px(bx + 2, by + bh, bw, 2, COL.shadow);

  // Walls
  px(bx, wallY, bw, wallH, b.wall);
  px(bx + bw - 2, wallY, 2, wallH, b.wallDk);
  px(bx, wallY + wallH - 1, bw, 1, b.wallDk);

  // Stair-step peaked roof
  const roofCx = bx + bw / 2;
  for (let i = 0; i < 5; i++) {
    const rw = bw + 4 - i * (bw / 5);
    const ry = by + roofH - (i + 1) * 2;
    px(roofCx - rw / 2, ry, rw, 2, i === 4 ? b.roofDk : b.roof);
  }
  // Overhang
  px(bx - 2, wallY, bw + 4, 1, b.roofDk);

  // Windows (one each side, 4×4)
  const winY = wallY + 4;
  px(bx + 6, winY, 4, 4, COL.windowBlue);
  px(bx + 6, winY, 4, 1, COL.windowFrame);
  px(bx + 7, winY, 2, 4, COL.windowFrame);
  px(bx + bw - 10, winY, 4, 4, COL.windowBlue);
  px(bx + bw - 10, winY, 4, 1, COL.windowFrame);
  px(bx + bw - 9, winY, 2, 4, COL.windowFrame);

  // Door (centered, 6×10)
  const doorW = 6;
  const doorH = 10;
  const doorX = bx + (bw - doorW) / 2;
  const doorY = by + bh - doorH;
  px(doorX, doorY, doorW, doorH, COL.doorBrown);
  px(doorX + 1, doorY - 1, doorW - 2, 1, COL.doorBrown);
  px(doorX + doorW - 1, doorY, 1, doorH, COL.doorDark);
  px(doorX + doorW - 2, doorY + doorH / 2, 1, 1, COL.roofGold);

  // Sign
  const signW = Math.min(b.sign.length * 7 + 6, bw + 8);
  const signX = bx + (bw - signW) / 2;
  const signY = wallY + 1;
  px(signX, signY, signW, 9, '#FFF8F0');
  px(signX, signY, signW, 1, b.signColor);
  px(signX, signY + 8, signW, 1, b.signColor);
  pxText(b.sign, bx + bw / 2, signY + 8, 7, b.signColor);
}

// ═══════════════════════════════════════
// HOOVER TOWER
// ═══════════════════════════════════════
function drawHooverTower() {
  const t = hooverTower;
  const bx = t.x * TILE;
  const by = t.y * TILE;
  const bw = t.w * TILE;  // 32
  const bh = t.h * TILE;  // 80
  const cx = bx + bw / 2;
  const bottom = by + bh;
  const P = 2; // uniform pixel block size

  // Shadow
  px(bx + 2, bottom, bw, 3, COL.shadow);

  // ═══ NARROW RECTANGULAR SHAFT ═══
  px(bx, by, bw, bh, COL.towerBeige);
  px(bx + bw - P, by, P, bh, COL.towerBeigeDk);

  // ═══ HORIZONTAL CORNICE BANDS ═══
  px(bx - P, by, bw + P * 2, P, COL.sandstoneLt);
  px(bx - P, by + 22, bw + P * 2, P, COL.sandstoneLt);
  px(bx - P, bottom - 16, bw + P * 2, P, COL.sandstoneLt);
  px(bx - P, bottom - P, bw + P * 2, P, COL.sandstoneDark);

  // ═══ WINDOW SLITS (2px wide, symmetric) ═══
  const slitH = 6;
  px(bx + 5, by + 8, P, slitH, COL.windowBlue);
  px(bx + bw - 5 - P, by + 8, P, slitH, COL.windowBlue);
  px(bx + 5, by + 26, P, slitH, COL.windowBlue);
  px(bx + bw - 5 - P, by + 26, P, slitH, COL.windowBlue);
  px(bx + 5, by + 42, P, slitH, COL.windowBlue);
  px(bx + bw - 5 - P, by + 42, P, slitH, COL.windowBlue);

  // ═══ ARCH DOORWAY ═══
  const doorW = 8;
  const doorH = 12;
  const doorX = cx - doorW / 2;
  const doorY = bottom - doorH;
  px(doorX, doorY + 4, doorW, doorH - 4, COL.archBrown);
  px(doorX + P, doorY + P, doorW - P * 2, P * 2, COL.archBrown);
  px(doorX, doorY + P * 2, P, P, COL.archBrown);
  px(doorX + doorW - P, doorY + P * 2, P, P, COL.archBrown);
  px(doorX + P, doorY + 6, doorW - P * 2, doorH - 6, '#5A4A38');

  // ═══ RED PIXELATED TRIANGLE TOP ═══
  const roofDark = '#8B3A3A';
  const roofMid = '#A04545';
  const roofLight = '#B85050';
  // Stair-step triangle: each layer P tall, shrinks by P each side
  const triBase = bw + 4;
  const layers = Math.floor(triBase / (P * 2));
  for (let i = 0; i < layers; i++) {
    const lw = triBase - i * P * 2;
    if (lw < P) break;
    const color = i < 2 ? roofDark : (i < layers - 2 ? roofMid : roofLight);
    px(cx - lw / 2, by - (i + 1) * P, lw, P, color);
  }
  // Eaves overhang
  px(cx - (triBase + 2) / 2, by - P, triBase + 2, P, roofDark);
  // Finial point
  const tipY = by - layers * P;
  px(cx - 1, tipY - 3, P, 3, COL.towerCap);

  // ═══ SIGN ═══
  const signText = 'HOOVER';
  const signW = signText.length * 7 + 6;
  const signSX = cx - signW / 2;
  const signSY = bottom - doorH - 12;
  px(signSX, signSY, signW, 9, '#FFF8F0');
  px(signSX, signSY, signW, 1, COL.towerCap);
  px(signSX, signSY + 8, signW, 1, COL.towerCap);
  pxText(signText, cx, signSY + 8, 7, COL.towerCap);
}

// ═══════════════════════════════════════
// PALM TREES
// ═══════════════════════════════════════
function drawPalmTree(t) {
  const x = t.x, y = t.y;

  // Shadow
  px(x - 2, y + 20, 12, 2, COL.shadow);

  // Trunk (curved, 18px tall)
  px(x + 4, y + 6, 3, 14, COL.palmTrunk);
  px(x + 5, y + 6, 1, 14, COL.palmTrunkDk);
  px(x + 3, y + 4, 3, 4, COL.palmTrunk);

  // Trunk ring markings
  for (let r = 0; r < 4; r++) {
    px(x + 4, y + 8 + r * 3, 3, 1, COL.palmTrunkDk);
  }

  // Coconuts
  px(x + 3, y + 4, 2, 2, COL.doorBrown);
  px(x + 6, y + 3, 2, 2, COL.doorBrown);
  px(x + 4, y + 3, 2, 2, COL.doorDark);

  // Fronds (simplified fan shape)
  const frondSets = [
    // Left fronds
    [[-1,-1],[-2,-1],[-2,0],[-3,0],[-2,1],[-1,1]],
    [[-1,-2],[-1,-1],[-2,0],[-2,1]],
    // Right fronds
    [[1,-1],[2,-1],[2,0],[3,0],[2,1],[1,1]],
    [[1,-2],[1,-1],[2,0],[2,1]],
    // Top fronds
    [[0,-1],[0,-2],[-1,-2],[1,-2],[0,-3]],
    [[0,-1],[1,-1],[-1,-1],[0,-2]],
  ];
  const frondColors = [COL.palmFrond, COL.palmFrondDk, COL.palmFrond, COL.palmFrondDk, COL.palmFrondLt, COL.palmFrond];
  const crownX = x + 4;
  const crownY = y + 2;

  frondSets.forEach((steps, idx) => {
    let fx = crownX, fy = crownY;
    steps.forEach(([sdx, sdy]) => {
      fx += sdx;
      fy += sdy;
      px(fx, fy, 2, 1, frondColors[idx]);
    });
  });
}

// ═══════════════════════════════════════
// TREES DRAWING
// ═══════════════════════════════════════
function drawTree(t) {
  const x = t.x, y = t.y;
  const s = t.size || 1;
  const sw = Math.round(14 * s), sh = Math.round(18 * s);

  // Shadow
  px(x, y + sh - 2, sw, 3, COL.shadow);

  // Trunk
  const tw = Math.round(4 * s), th = Math.round(8 * s);
  const tx = x + (sw - tw) / 2;
  const ty = y + sh - th - 2;
  px(tx, ty, tw, th, COL.treeTrunk);
  px(tx + Math.round(s), ty + Math.round(s), Math.round(2 * s), th - Math.round(2 * s), COL.treeTrunkDark);

  // Canopy
  const cw = Math.round(12 * s), ch = Math.round(10 * s);
  const cx = x + (sw - cw) / 2;
  const cy = y;
  // Main canopy shape
  px(cx + 2, cy, cw - 4, ch, COL.canopy);
  px(cx, cy + 2, cw, ch - 4, COL.canopy);
  px(cx + 1, cy + 1, cw - 2, ch - 2, COL.canopy);
  // Highlights
  px(cx + 3, cy + 1, Math.round(4 * s), Math.round(3 * s), COL.canopyLight);
  // Depth
  px(cx + 2, cy + ch - 3, cw - 4, 2, COL.canopyDark);
  px(cx + Math.round(6 * s), cy + 3, Math.round(3 * s), Math.round(4 * s), COL.canopyDark);
}

// ═══════════════════════════════════════
// FLOWERS DRAWING
// ═══════════════════════════════════════
function drawFlower(f) {
  const colors = [COL.flowerPink, COL.flowerYellow, COL.flowerPurple, COL.flowerWhite];
  const c = colors[f.type];
  const bob = Math.sin(time * 0.04 + f.phase) * 0.5;
  const fy = f.y + bob;

  // Stem
  px(f.x + 1, fy + 3, 1, 3, COL.canopy);
  // Petals
  px(f.x, fy + 1, 1, 1, c);
  px(f.x + 2, fy + 1, 1, 1, c);
  px(f.x + 1, fy, 1, 1, c);
  px(f.x + 1, fy + 2, 1, 1, c);
  // Center
  px(f.x + 1, fy + 1, 1, 1, COL.flowerCenter);
}

// ═══════════════════════════════════════
// PLAYER DRAWING
// ═══════════════════════════════════════
function drawPlayer() {
  const x = player.x - 5;
  const y = player.y - 7;
  const dir = player.dir;
  const f = player.frame;
  const bob = player.moving ? Math.sin(time * 0.3) * 0.5 : 0;
  const dy = bob;

  // Shadow
  px(player.x - 4, player.y + 6, 8, 2, COL.shadow);

  if (dir === 'down') {
    // Ponytail (behind, peeks on right side)
    px(x + 9, y + 3 + dy, 2, 5, COL.hair);
    px(x + 10, y + 5 + dy, 1, 4, COL.hair);
    // Hair
    px(x + 2, y + dy, 7, 1, COL.hair);
    px(x + 1, y + 1 + dy, 9, 2, COL.hair);
    // Face
    px(x + 2, y + 3 + dy, 7, 3, COL.skin);
    // Hair sides
    px(x + 1, y + 3 + dy, 1, 2, COL.hair);
    px(x + 9, y + 3 + dy, 1, 2, COL.hair);
    // Eyes
    px(x + 3, y + 4 + dy, 2, 1, COL.eyeWhite);
    px(x + 6, y + 4 + dy, 2, 1, COL.eyeWhite);
    px(x + 4, y + 4 + dy, 1, 1, COL.eyes);
    px(x + 7, y + 4 + dy, 1, 1, COL.eyes);
    // Blush
    px(x + 2, y + 5 + dy, 1, 1, COL.blush);
    px(x + 8, y + 5 + dy, 1, 1, COL.blush);
    // Body
    px(x + 2, y + 6 + dy, 7, 1, COL.shirt);
    px(x + 1, y + 7 + dy, 9, 3, COL.shirt);
    px(x + 2, y + 10 + dy, 7, 1, COL.shirt);
    // Shirt shadow
    px(x + 1, y + 9 + dy, 9, 1, COL.shirtDark);
    // Legs
    if (f === 0) {
      px(x + 3, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 6, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 3, y + 13 + dy, 2, 1, COL.shoes);
      px(x + 6, y + 13 + dy, 2, 1, COL.shoes);
    } else {
      px(x + 2, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 7, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 2, y + 13 + dy, 2, 1, COL.shoes);
      px(x + 7, y + 13 + dy, 2, 1, COL.shoes);
    }
  } else if (dir === 'up') {
    // Ponytail (back view, fully visible)
    px(x + 4, y + 2 + dy, 3, 1, COL.hair);
    px(x + 4, y + 3 + dy, 2, 6, COL.hair);
    px(x + 5, y + 7 + dy, 1, 3, COL.hair);
    // Hair (back view)
    px(x + 2, y + dy, 7, 1, COL.hair);
    px(x + 1, y + 1 + dy, 9, 4, COL.hair);
    px(x + 2, y + 5 + dy, 7, 1, COL.hair);
    // Body
    px(x + 2, y + 6 + dy, 7, 1, COL.shirt);
    px(x + 1, y + 7 + dy, 9, 3, COL.shirt);
    px(x + 2, y + 10 + dy, 7, 1, COL.shirt);
    px(x + 1, y + 9 + dy, 9, 1, COL.shirtDark);
    // Legs
    if (f === 0) {
      px(x + 3, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 6, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 3, y + 13 + dy, 2, 1, COL.shoes);
      px(x + 6, y + 13 + dy, 2, 1, COL.shoes);
    } else {
      px(x + 2, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 7, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 2, y + 13 + dy, 2, 1, COL.shoes);
      px(x + 7, y + 13 + dy, 2, 1, COL.shoes);
    }
  } else if (dir === 'left') {
    // Ponytail (hangs on back/right side)
    px(x + 8, y + 3 + dy, 2, 5, COL.hair);
    px(x + 9, y + 5 + dy, 1, 4, COL.hair);
    // Hair
    px(x + 2, y + dy, 6, 1, COL.hair);
    px(x + 1, y + 1 + dy, 8, 2, COL.hair);
    // Face
    px(x + 1, y + 3 + dy, 7, 3, COL.skin);
    px(x + 1, y + 3 + dy, 1, 2, COL.hair);
    // Eye
    px(x + 3, y + 4 + dy, 2, 1, COL.eyeWhite);
    px(x + 3, y + 4 + dy, 1, 1, COL.eyes);
    // Blush
    px(x + 2, y + 5 + dy, 1, 1, COL.blush);
    // Body
    px(x + 1, y + 6 + dy, 7, 1, COL.shirt);
    px(x + 1, y + 7 + dy, 8, 3, COL.shirt);
    px(x + 1, y + 10 + dy, 7, 1, COL.shirt);
    px(x + 1, y + 9 + dy, 8, 1, COL.shirtDark);
    // Legs
    if (f === 0) {
      px(x + 3, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 5, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 3, y + 13 + dy, 2, 1, COL.shoes);
      px(x + 5, y + 13 + dy, 2, 1, COL.shoes);
    } else {
      px(x + 2, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 5, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 2, y + 13 + dy, 2, 1, COL.shoes);
      px(x + 5, y + 13 + dy, 2, 1, COL.shoes);
    }
  } else { // right
    // Ponytail (hangs on back/left side)
    px(x, y + 3 + dy, 2, 5, COL.hair);
    px(x, y + 5 + dy, 1, 4, COL.hair);
    // Hair
    px(x + 3, y + dy, 6, 1, COL.hair);
    px(x + 2, y + 1 + dy, 8, 2, COL.hair);
    px(x + 3, y + 3 + dy, 7, 3, COL.skin);
    px(x + 9, y + 3 + dy, 1, 2, COL.hair);
    px(x + 6, y + 4 + dy, 2, 1, COL.eyeWhite);
    px(x + 7, y + 4 + dy, 1, 1, COL.eyes);
    px(x + 8, y + 5 + dy, 1, 1, COL.blush);
    px(x + 3, y + 6 + dy, 7, 1, COL.shirt);
    px(x + 2, y + 7 + dy, 8, 3, COL.shirt);
    px(x + 3, y + 10 + dy, 7, 1, COL.shirt);
    px(x + 2, y + 9 + dy, 8, 1, COL.shirtDark);
    if (f === 0) {
      px(x + 4, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 6, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 4, y + 13 + dy, 2, 1, COL.shoes);
      px(x + 6, y + 13 + dy, 2, 1, COL.shoes);
    } else {
      px(x + 4, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 7, y + 11 + dy, 2, 2, COL.skirt);
      px(x + 4, y + 13 + dy, 2, 1, COL.shoes);
      px(x + 7, y + 13 + dy, 2, 1, COL.shoes);
    }
  }

  // Interaction prompt above head
  if (nearBuilding && !dlgActive) {
    const promptY = y - 6 + Math.sin(time * 0.08) * 1.5;
    px(x + 1, promptY, 9, 6, 'rgba(42,63,42,0.85)');
    pxText('SPACE', player.x, promptY + 5, 6, '#FAF3E0');
  }
}

// ═══════════════════════════════════════
// BUTTERFLIES (ambient)
// ═══════════════════════════════════════
const butterflies = [];
for (let i = 0; i < 5; i++) {
  butterflies.push({
    x: Math.random() * MW * TILE,
    y: Math.random() * MH * TILE * 0.8 + MH * TILE * 0.1,
    vx: (Math.random() - 0.5) * 0.4,
    vy: (Math.random() - 0.5) * 0.3,
    phase: Math.random() * Math.PI * 2,
    color: [COL.flowerPink, COL.flowerYellow, COL.flowerPurple, '#FFF8F0'][Math.floor(Math.random() * 4)],
  });
}

function updateButterflies() {
  butterflies.forEach(bf => {
    bf.x += bf.vx + Math.sin(time * 0.02 + bf.phase) * 0.3;
    bf.y += bf.vy + Math.cos(time * 0.015 + bf.phase) * 0.2;
    if (bf.x < 0) bf.x = MW * TILE;
    if (bf.x > MW * TILE) bf.x = 0;
    if (bf.y < 16) bf.y = 16;
    if (bf.y > MH * TILE - 16) bf.y = MH * TILE - 16;
  });
}

function drawButterflies() {
  butterflies.forEach(bf => {
    const wingSpread = Math.sin(time * 0.15 + bf.phase) * 2;
    px(bf.x - 1 - Math.abs(wingSpread), bf.y, 1 + Math.abs(wingSpread), 1, bf.color);
    px(bf.x + 1, bf.y, 1 + Math.abs(wingSpread), 1, bf.color);
    px(bf.x, bf.y, 1, 2, COL.textDark);
  });
}

// ═══════════════════════════════════════
// DIALOGUE SYSTEM
// ═══════════════════════════════════════
function openDialogue(building) {
  dlgActive = true;
  dlgBuilding = building;
  dlgPage = 0;
  dlgCharIdx = 0;
  const el = document.getElementById('dialogue');
  el.style.display = 'block';
  updateDialogueDOM();
}

function updateDialogueDOM() {
  const page = dlgBuilding.pages[dlgPage];
  document.getElementById('dlg-title').textContent = page.title;
  document.getElementById('dlg-content').textContent = '';
  document.getElementById('dlg-page').textContent =
    dlgBuilding.pages.length > 1 ? `${dlgPage + 1}/${dlgBuilding.pages.length}` : '';
  document.getElementById('dlg-prompt').style.visibility = 'hidden';
  dlgCharIdx = 0;
}

function advanceDialogue() {
  if (!dlgActive) return;
  const page = dlgBuilding.pages[dlgPage];
  if (dlgCharIdx < page.text.length) {
    dlgCharIdx = page.text.length;
    document.getElementById('dlg-content').textContent = page.text;
    document.getElementById('dlg-prompt').style.visibility = 'visible';
  } else if (dlgPage < dlgBuilding.pages.length - 1) {
    dlgPage++;
    updateDialogueDOM();
  } else {
    closeDialogue();
  }
}

function closeDialogue() {
  dlgActive = false;
  dlgBuilding = null;
  document.getElementById('dialogue').style.display = 'none';
}

function tickDialogue() {
  if (!dlgActive) return;
  const page = dlgBuilding.pages[dlgPage];
  if (dlgCharIdx < page.text.length) {
    dlgCharIdx++;
    document.getElementById('dlg-content').textContent = page.text.substring(0, dlgCharIdx);
    if (dlgCharIdx >= page.text.length) {
      document.getElementById('dlg-prompt').style.visibility = 'visible';
    }
  }
}

// ═══════════════════════════════════════
// INPUT
// ═══════════════════════════════════════
function startGame() {
  if (started) return;
  started = true;
  document.getElementById('splash').classList.add('fade');
  setTimeout(() => document.getElementById('splash').style.display = 'none', 1000);
}

// Click anywhere to start (splash or document)
document.getElementById('splash').addEventListener('click', startGame);
document.addEventListener('click', () => {
  if (!started) startGame();
});

window.addEventListener('keydown', e => {
  if (e.key === ' ') e.preventDefault();
  if (e.repeat) return;
  keys[e.key] = true;

  if (e.key === ' ' || e.key === 'Enter') {
    if (!started) {
      startGame();
      return;
    }
    if (dlgActive) {
      advanceDialogue();
      return;
    }
    if (nearBuilding) {
      openDialogue(nearBuilding);
    }
  }

  if (e.key === 'Escape' && dlgActive) {
    closeDialogue();
  }
}, true);

window.addEventListener('keyup', e => {
  if (e.key === ' ') e.preventDefault();
  keys[e.key] = false;
}, true);

// Touch controls
const touchDirs = {};
document.querySelectorAll('.dpad button').forEach(btn => {
  const dir = btn.dataset.dir;
  const keyMap = { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' };
  btn.addEventListener('touchstart', e => {
    e.preventDefault();
    keys[keyMap[dir]] = true;
  });
  btn.addEventListener('touchend', e => {
    e.preventDefault();
    keys[keyMap[dir]] = false;
  });
});

document.getElementById('touch-action').addEventListener('touchstart', e => {
  e.preventDefault();
  if (!started) {
    startGame();
    return;
  }
  if (dlgActive) { advanceDialogue(); return; }
  if (nearBuilding) { openDialogue(nearBuilding); }
});

// ═══════════════════════════════════════
// UPDATE
// ═══════════════════════════════════════
let typeTimer = 0;

function update() {
  time++;
  if (!started) return;

  // Typewriter
  typeTimer++;
  if (typeTimer % 2 === 0) tickDialogue();

  if (dlgActive) return;

  // Movement
  player.moving = false;
  let dx = 0, dy = 0;

  if (keys['ArrowUp'] || keys['w'] || keys['W']) { dy = -player.speed; player.dir = 'up'; }
  if (keys['ArrowDown'] || keys['s'] || keys['S']) { dy = player.speed; player.dir = 'down'; }
  if (keys['ArrowLeft'] || keys['a'] || keys['A']) { dx = -player.speed; player.dir = 'left'; }
  if (keys['ArrowRight'] || keys['d'] || keys['D']) { dx = player.speed; player.dir = 'right'; }

  if (dx !== 0 || dy !== 0) {
    player.moving = true;
    if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
    if (canMove(player.x + dx, player.y)) player.x += dx;
    if (canMove(player.x, player.y + dy)) player.y += dy;
  }

  // Walk animation
  if (player.moving) {
    player.frameTimer++;
    if (player.frameTimer > 8) {
      player.frame = 1 - player.frame;
      player.frameTimer = 0;
    }
  } else {
    player.frame = 0;
    player.frameTimer = 0;
  }

  // Check nearby buildings
  nearBuilding = null;
  for (const b of buildings) {
    const doorX = (b.x + b.w / 2) * TILE;
    const doorY = (b.y + b.h) * TILE + TILE;
    const dist = Math.hypot(player.x - doorX, player.y - doorY);
    if (dist < TILE * 2) {
      nearBuilding = b;
      break;
    }
  }
  // Check Hoover Tower proximity
  if (!nearBuilding) {
    const htDoorX = (hooverTower.x + hooverTower.w / 2) * TILE;
    const htDoorY = (hooverTower.y + hooverTower.h) * TILE + TILE;
    const htDist = Math.hypot(player.x - htDoorX, player.y - htDoorY);
    if (htDist < TILE * 2) {
      nearBuilding = hooverTower;
    }
  }

  // Camera (smooth follow)
  const targetX = player.x * S - canvas.width / 2;
  const targetY = player.y * S - canvas.height / 2;
  cam.x += (targetX - cam.x) * 0.08;
  cam.y += (targetY - cam.y) * 0.08;

  const maxCamX = Math.max(0, MW * TILE * S - canvas.width);
  const maxCamY = Math.max(0, MH * TILE * S - canvas.height);
  cam.x = Math.max(0, Math.min(cam.x, maxCamX));
  cam.y = Math.max(0, Math.min(cam.y, maxCamY));

  // Center if world smaller than viewport
  if (MW * TILE * S < canvas.width) cam.x = -(canvas.width - MW * TILE * S) / 2;
  if (MH * TILE * S < canvas.height) cam.y = -(canvas.height - MH * TILE * S) / 2;

  updateButterflies();
}

// ═══════════════════════════════════════
// RENDER
// ═══════════════════════════════════════
function render() {
  // Clear with dark bg (visible if world doesn't fill screen)
  ctx.fillStyle = '#1a2a1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawGround();
  drawFountainAnim();

  // Collect all y-sorted entities
  const entities = [];

  buildings.forEach(b => {
    entities.push({ y: (b.y + b.h) * TILE, fn: () => drawBuilding(b) });
  });

  // Hoover Tower
  entities.push({
    y: (hooverTower.y + hooverTower.h) * TILE,
    fn: () => drawHooverTower()
  });

  trees.forEach(t => {
    entities.push({ y: t.y + 16, fn: () => drawTree(t) });
  });

  // Palm trees
  palmTrees.forEach(t => {
    entities.push({ y: t.y + 20, fn: () => drawPalmTree(t) });
  });

  entities.push({ y: player.y + 7, fn: () => drawPlayer() });

  // Sort by y position (draw from top to bottom)
  entities.sort((a, b) => a.y - b.y);
  entities.forEach(e => e.fn());

  // Flowers on top (they're flat on the ground)
  flowers.forEach(f => drawFlower(f));

  drawButterflies();
}

// ═══════════════════════════════════════
// MINIMAP
// ═══════════════════════════════════════
function drawMinimap() {
  const mc = document.createElement('canvas');
  const mw = 160, mh = Math.round(mw * MH / MW);
  mc.width = mw; mc.height = mh;
  const mx = mc.getContext('2d');
  const sx = mw / MW, sy = mh / MH;

  // Background
  mx.fillStyle = COL.grass2;
  mx.fillRect(0, 0, mw, mh);

  // Paths
  mx.fillStyle = COL.path;
  paths.forEach(p => {
    mx.fillRect(p.x * sx, p.y * sy, p.w * sx, p.h * sy);
  });

  // Fountain
  mx.fillStyle = COL.water;
  mx.fillRect(fountain.x * sx, fountain.y * sy, fountain.w * sx, fountain.h * sy);

  // Buildings
  buildings.forEach(b => {
    mx.fillStyle = b.roof;
    mx.fillRect(b.x * sx, b.y * sy, b.w * sx, b.h * sy);
  });

  // Hoover Tower
  mx.fillStyle = COL.towerCap;
  mx.fillRect(hooverTower.x * sx, hooverTower.y * sy, hooverTower.w * sx, hooverTower.h * sy);

  // Player
  mx.fillStyle = time % 40 < 25 ? '#FFFFFF' : '#FFE0B2';
  const psx = player.x / TILE * sx;
  const psy = player.y / TILE * sy;
  mx.fillRect(psx - 2, psy - 2, 4, 4);

  return mc;
}

// Minimap element
const minimapEl = document.createElement('canvas');
minimapEl.id = 'minimap-display';
minimapEl.style.cssText = 'position:fixed;bottom:14px;right:14px;z-index:90;border:2px solid #52A375;background:rgba(42,63,42,0.5);image-rendering:pixelated;';
document.body.appendChild(minimapEl);

let minimapTimer = 0;
function updateMinimap() {
  minimapTimer++;
  if (minimapTimer % 6 !== 0) return;
  const mc = drawMinimap();
  minimapEl.width = mc.width;
  minimapEl.height = mc.height;
  minimapEl.getContext('2d').drawImage(mc, 0, 0);
}

// ═══════════════════════════════════════
// GAME LOOP
// ═══════════════════════════════════════
function gameLoop() {
  update();
  render();
  if (started) updateMinimap();
  requestAnimationFrame(gameLoop);
}

// ═══════════════════════════════════════
// INIT
// ═══════════════════════════════════════
placeTrees();
placeFlowers();
buildCollisions();
renderGroundCache();

// Center camera on player initially
cam.x = player.x * S - canvas.width / 2;
cam.y = player.y * S - canvas.height / 2;
const maxCamX = Math.max(0, MW * TILE * S - canvas.width);
const maxCamY = Math.max(0, MH * TILE * S - canvas.height);
cam.x = Math.max(0, Math.min(cam.x, maxCamX));
cam.y = Math.max(0, Math.min(cam.y, maxCamY));

// Ensure splash has focus for keyboard input
window.focus();
document.getElementById('splash').focus();

gameLoop();
</script>
</body>
</html>
